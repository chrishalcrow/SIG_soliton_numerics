---
title: Good Scientific Software Practices, through Solitons
output: html_document
theme: zephyr
format:
  html:
    toc: true
    toc-location: left
---

# Introduction

Software engineering is now an integral part of science. As mathematicians and physicists, 
we're pretty good at understanding algorithms, and even implementing them. But to ensure 
our code is easy to use, sharable, reproducible, tested and reliable we need to do a lot
more than implement an algorithm. Modern software development involves continuous integration, 
linters, typers, LSPs, code coverage, automatically-generated docs, and more! 

This course will focus on these "soft skills" of software. As such, we'll be spending a lot of time setting up our project and development environment and thinking about our workflow. Then once we get to coding itself, we'll go through that quite quickly.

These notes are designed to be self contained. You can start the course RIGHT NOW. You can 
suggest edits and raise issues on the [GitHub page](https://github.com/chrishalcrow/SIG_soliton_numerics/tree/gh-pages).

## Plan for the course in Krakow

We have four sessions. In each one, I'll give a brief introduction to the topic, then you 
will follow the notes and try and get some code working. If you'd like to spend this time 
simply working on your existing code: go for it!

By the end of the course, we'll have made a small package to create a one-dimensional 
soliton and apply a flow to it. This is not scientifically revolutionary, but the code we 
make will have many good practices built into it. It will have tests and documentation. 
It'll be readable, reproducible and published openly on GitHub. With this structure, 
I hope you can use this project as a base for future work.

So that everyone has the same experience, we'll be using Python. If you'd prefer to use a 
different language, go for it! You'll have to translate the Python code/concepts here into
your favorite language, but that shouldn't be too hard. C++, Julia and Matlab 
are all reasonable choices. We will use Python because it's quite easy to get started with 
and it's the most popular (and employable) language in the world. Python is traditionally 
thought to be slow, and it can be. But if you know how it works it can be just as fast as 
any other language. I also recommend writing the code in VSCode or PyCharm.

# Detailed Plan

1. Before the course:
  - Installation
2. Monday
  - Make a Project
  - Git and GitHub
3. Tuesday
  - Source and scripts
  - Functions, classes and methods <-- coding only begins here!!
  - Lots of code!
4. Thursday
  - Compute derivatives and the energy 
  - Plot a soliton
  - Save/Load a soliton
5. Friday
  - Gradient flow
6. Bonus
  - Tests
  - Documentation
  - Optimization
  - Linters, formatters and LSPs
  - Continuous Integration
  - Recommended Reading

# Installation

## The terminal

The terminal is a nice way to interact with your computer. If you're using Mac or Linux you 
have a terminal installed already. It's called Terminal. If you have Windows, you have 
Powershell. So that everyone has a similar experience, I encourage you to install Windows 
Terminal (there are installation instructions on [its GitHub page]( 
https://github.com/microsoft/terminal)

Open your terminal and type "ls" (short for "list") then press enter. This will display 
all the files in your currently directory. If you want to change directories type "cd " 
followed by the name of the directroy you want to go to.

## uv (to install python + packages)

Python's biggest asset (and liability) is that people write packages for it. There are over 
600,000 packages available on [PyPi](https://pypi.org). These packages usually depend on
each other, and it can get overwhelming keeping track. As such, we'll use a 
installation/package manager called `uv`. This will install python and the packages for us, 
and help initialise our project. To install uv follow the instructions on [uv's website](https://docs.astral.sh/uv/#installation). Check it works by opening a Terminal (on Mac or 
Linux) and typing `uv`.

Once you have uv, you can run python in the terminal by typing `uv run python`. The first 
time you do this uv might install Python. So it might take a little minute.

## An editor

A good text editor _really_ helps coding. A good one allows you to search through 
codebases, auto-complete code, and more. I recommend [VSCode](https://code.visualstudio.com/) 
because it's free and has really good Python support. Some people love [PyCharm](https://www.jetbrains.com/pycharm/). Please install one.

Both VScode and PyCharm have lots of extensions. For VSCode, please install the Python extension.

## Git

Check that you have git installed by typing 'git' then pressing enter in your Terminal. 
It's hopefully already installed. If not, [please install it](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) This is a good moment to make a [https://github.com/](GitHub account too).

# Make a project

We're going to make a Python Package. First choose a name. I'll be using `solitons1d`. Find a place you want to store your project. Initialise a new python package by typing e.g. `uv init --package solitons1d` in Terminal and pressing enter.  Go have a look in the folder (either using your File Explorer or typing `ls` into Terminal). There should be four files inside the folder. uv has made these:

- README.md This file is what a new user will first read when they encounter your project. 
It should contain a description of the project, installation instructions and anything else 
you'd like. It's written in markdown, which isn't too far from plain text 
(https://www.markdownguide.org/).
- pyproject.toml This file contains all the information about your project. Its name, version, 
description etc. Add some of your own details if you'd like. This file will also keep track 
of which other packages your package depends on once we add some.
- uv.lock Keeps the _detailed_ information about package dependencies.
- src/solitons1d. A folder which will contain your package.

Ok! Let's open the project in VSCode. The easiest way to do this is in terminal. We're going
to do something slightly fancy that will make sense later, and open it with uv. Do this by 
navigating to the project folder in Terminal then typing `uv run code .`. The dot at the end
means "this folder here". `code` is the shortcut for VSCode and `uv run` means "When you open
VSCode, make it aware of which python _enviroment_ is being used at the moment". More on 
enviroments soon!

VSCode should have opened, and you should see the project directory at the left hand side. 
There should also be a Terminal at the bottom. If there isn't you can put it there using 
`View -> Terminal`. From the terminal we can run python by entering `uv run python`, then import our package using `import solitons1d`. Quit python by running `exit()`. Note: we won't use python in the terminal much.

If that didn't error - amazing!! You've just set up your developer workflow. I think doing 
this is actually one of the hardest parts of coding. I've shown you my workflow which is 
fairly standard; but everyone has their own. You can read thousands of articles and YouTube 
videos (just search neovim for python on YouTube to really start going down the rabbit hole). 

## Virtual Enviroments

Ok, I've been sweeping the following topic under the rug but it's very important to 
understand: virtual enviroments. Because python has so many packages and their 
dependencies are complex, it's considered good behaviour to make a different 
enviroment for different projects. So you might have one enviroment for when you do 
statistics, one for when you do heavy numerical stuff and another for plotting. `uv` 
takes this to the extreme: it makes a new virtual enviroment every time you run 
python. When we ran `uv run code .` it make a folder called `.venv` containing the information 
about the enviroment. Then it opened VSCode and told it that we're using this enviroment. 
This means VSCode is aware of which packages we've installed. This is gonna be _super_ helpful 
later.

Let's add some package dependencies to our package. In the terminal, navigate to your 
project folder. We'll add the package numpy by running `uv add numpy`. This will add 
numpy to the project by adding it to the `pyproject.toml` file.

You might notice another new file in your project folder called `uv.lock`. This keeps 
all the intricate details about the packages. It's gross.

# Git and GitHub

Git is version control software. It keeps track of changes you make in the code, so you can 
easily revert to previous versions. It's really helpful when you work on a big project with 
several contributors. When a bug gets introduced you can usually immediately figure out who 
caused it!

GitHub is run by Microsoft. It's where you can publish your software. It uses Git to keep 
track of changes etc.

The idea here is to have one copy of your project on your local computer, and one copy of your project on GitHub. We'll then link the two copies together, so changes you make locally can get applied to the remote (GitHub) copy. Then GitHub takes care of a lot of nice things, which we'll get on to later.

There are lots of ways to link your local and remote repos. For more info, try: https://github.com/git-guides/git-init . 

It can get a bit messy at the start here, **so please follow these instructions carefully:**

We'll make a GitHub repository (repo) and link it to this folder. Go to github.com, make an account then create a new repository. DON'T DO ANYTHING except add the repository name, then press "Create repository". Towards the bottom of the next page you should see the heading "...or push an existing repository from the command line", with some commands to run. Something like:

```
git remote add origin https://github.com/chrishalcrow/Solitons1D.git
git branch -M main
git push -u origin main
```

Run these three commands from your local repo folder in Terminal. They say:
- "Link the git in this folder to this github repository"
- "Create the primary 'branch' of the repo, called main"
- "Push (put, or add) everything from the folder to the repo on github.com"

If that worked: great! You're project is now _online_! If the last one error'd, that's ok. We'll get that sorted soon.

# Sources and scripts

As we build our package, we should keep a separation between the "source" and "scripts". 
The source is our package itself. This will contain the logic which can _do things_ and that you want to share with other people. Functions like `compute_energy`, `make_soliton` and more. But when we use the package to do science, we'd write a script. The script will import functions from the source and apply them to a specific case. A script might make a soliton, apply a gradient flow, compute the energy, then plot the result and save the figure as a pdf.

To make this distiction obvious, we'll make two folders in the project folder. One 
called "src" that `uv` already created for us (short for source - this shortening is conventional) and one called 
"scripts". In the "src" there should already be another folder called the name of your package. Inside this there is a file called `__init__.py` which tells Python that this folder contains a "module". Let's create another files in 
the `source/{project_name}` folder called `soliton.py`, which will contain the code 
about the soliton, Also add a script file called  `play.ipynb` in the scripts folder. Overall, my project folder looks like this:

``` python
solitons1D/
    pyproject.toml
    README.md
    scripts/
        play.ipynb
    src/
        solitons1D/
	        __init__.py
	        soliton.py
    uv.lock
```

# Functions, classes and methods

Ok - let's start coding!!

## Functions

Let's make a function. Functions take some input and return some output. Let's make a 
`create_profile` function which will generate a profile for a 1D soliton. For now, 
we'll just return an array of 0s:

``` python
import numpy as np

def create_profile(num_grid_points):
    profile = np.zeros(num_grid_points)
    return profile
```

I'll write this out in English:

- "Import the package called numpy and call it np, which is how we'll be able to access it."
- "Define a function called `create_profile`, which will accept the argument `num_grid_points`."
- "Use the function `zeros` from the numpy library. (This will create an array of zeros). Assign this array of zeros to the variable `profile`."
- "Return the variable `profile`. This return signals the end of the function

There are several improvements we can make to code immediately, we can: add type 
information about the arguments and returned parameter; add a docstring describing the function.

``` python
import numpy as np

def create_profile(num_grid_points: int) -> np.array:
    """
    Creates a profile function for a grid with 
    `num_grid_points` points.

    Parameters
    ----------
    num_grid_points: int
        Number of grid points

    Returns
    -------
    profile: np.array
        Generated profile function 
    """

    profile = np.zeros(num_grid_points)
    return profile
```

Ok. Let's use this function. We're going to use `play.ipynb`. This is a Jupyter notebook. To use it, we need to install another package to our enviroment. In the terminal, navigate to the project folder, type "uv add ipykernel" then press enter. Now open `play.ipynb` in VSCode.

A Jupyter notebook allows you to run little snippets of code in a "cell". We need to  import our function from our package, then run it. Put this code in your first cell

``` python
from solitons1d.soliton import create_profile
profile = create_profile(100)
profile
```

and execute this (either by pressing the "play" button next to the cell or pressing 
shift+enter). The final line of the cell gets displayed underneate it. So we should see 
a large array of 0s.

## Classes and methods

Functions are fine. But classes are the heart of object-orientated programming. Think of a class as an abstract definition like a Group (from Group Theory). Then we can create objects which conform to the class definition (like we can create $D_4$, a specific example of a group). In `src/soliton.py`, let's make a class which will represent a soliton. When you make a specific instance of a class (object), it is "initialised". During initialisation, we can choose what information to store in the object. 

``` python
class Soliton():

    def __init__(self, num_grid_points, grid_spacing):
         self.num_grid_points = num_grid_points
	     self.grid_spacing = grid_spacing
	     self.profile = create_profile(num_grid_points)
```

In English:

- "Define a class called Soliton"
- "Define the initialisation method, which will accept two numbers, the number of grid points and the grid spacing."
- "store the number of grid points"
- "store the grid spacing"
- "Make a profile function using the `create_profile` function and store it in `profile`.

Now, back in your script, make a Soliton object:

``` python
from solitons1d import Soliton
my_soliton = Soliton(100,0.1)
print(my_soliton.num_grid_points)
```

- "from the solitons1d package, import the class Soliton"
- "use the Soliton class to initialise a soliton with 100 grid points and 0.1 grid spacing called `my_soliton`"
- "take the soliton I just made, and get the number of grid points. Print this."

Great! Hopefully you can see that it's helpful to have an object that contains some information. 

## Methods

Even more helpful: write class-specific functions that can change what's in the object. 
These are called "methods". They're similar to functions but are designed to only be applied 
to the class. These are defined in the class definition itself. Let's create a method which
will (eventually) compute the energy of the soliton. The Soliton class method get updated 
to the following:

``` python
class Soliton():

    def __init__(self, num_grid_points, grid_spacing):
         self.lp = num_grid_points
	     self.ls = grid_spacing
	     self.profile = create_profile(num_grid_points)

    def compute_energy(self)

         total_energy = np.sum(self.profile)
	     total_energy *= self.ls
	     self.energy = total_energy
```

Now we have a method that takes in the profile function, sums it up, multiplies this 
value by the grid spacing, stores the value in `self.energy` then returns this value. 
We can use it in a script as follows:

``` python
my_soliton.compute_energy()
print(my_soliton.energy)
```

We've now got the basic building block that we'll use for the rest of the course.

## Upload to GitHub

Now that we have a few functions, methods, and classes: let's sync our local folder with our GitHub repository. You can do this using the Terminal (), but VSCode has some great Git integration. So let's use that. Find the "Source Control" button in VSCode. When you press it, it should show a list of files that you have made changes to. The logic is:

1. "Stage" the files you want to upload to GitHub. Do this by selecting the files you want to stage, right-clicking, then choosing "Stage Files".
2. Commit and Push the staged files to GitHub. Do this by first writing a message in the Message box. Maybe "Added Soliton class". Then press the down arrow at the right hand side of the commit button, and click "Commit and Push".

The first time you do this, you might need to Publish your branch. Every other time, it's just the 2-step process above.

Now go to your github page (mine is github.com/chrishalcrow/solitons1d/) and see if your changes have appeared there.

# Lots of code!

Let's get starting coding! I'll explain the overall structure of the codebase, then we'll go through the actual code very quickly. In each subsection, I'll get an overview then present the code.

Our centerpiece is the `Soliton` class. The `Soliton` will contain a `Grid` object and a `Lagrangian` object, keeping the numerical grid maintained and the mathematical details of the theory respectively. By doing this, each `Soliton` will know what theory is belongs to - handy. A `Soliton` object will contain methods allowing one to create an initial profile function, compute the energy and gradient flow.

Note: Another programmer might make this differently. Maybe having a `Grid` object is overkill. Maybe allowing the user to specify a generic Lagrangian is silly - you might just hardcode the Lagrangian you'd like in your `Soliton` object. Play around, debate, and figure out your style.

## The `Grid` class

A user can create a grid by specifying the number of grid points and the grid spacing. The `Grid` will then compute a grid (saved as `numpy` array) and save the length of the grid.

Add this to `soliton.py`:

``` python
import numpy as np

class Grid:
    """
    A 1D grid.

    Parameters
    ----------
    num_grid_points : int
        Number of grid points used in grid.
    grid_spacing : float
        Spacing between grid points.

    Attributes
    ----------
    grid_length : float
        Total length of grid.
    grid_points : np.array[float]
        An array of grid points, of the grid.

    """

    def __init__(
        self,
        num_grid_points: int,
        grid_spacing: float,
    ):
        self.num_grid_points = num_grid_points
        self.grid_spacing = grid_spacing
        self.grid_length = (num_grid_points) * grid_spacing

        self.grid_points = np.arange(
            -self.grid_length / 2, self.grid_length / 2, grid_spacing
        )

```

Possible improvements:

- Allow the user to specify the grid in other ways: by providing the start and end points, for example. Question: How do you make the code flexible to allow the user to do several different things. Hint: `If num_grid_points is None:`

Question:

- What's the difference between a Parameter and an Attribute?

Use. Make a grid as follow in a script:

``` python
from solitons1d.soliton import Grid
my_grid = Grid(200,0.1)
```

## Make a `Lagrangian` class

The Lagrangian will keep track of the potential function. We won't set up automatic differentiation, so we'll also give the Lagrangian the derivative of the potential. We'll also optionally allow the user to input the vacua of the theory. If they do, we'll add a check that the derivative function of the vacua return 0. This class could also be where we define how many fields our theory has, any funny metric, and more. But let's keep it simple for now.

``` python
class Lagrangian:
    """
    Used to represent Lagrangians of the form:
        L = - 1/2(dx_phi)^2 - V(phi)

    Parameters
    ----------
    V : function
        The potential energy function, must be a map from R -> R
    dV : function
        The derivative of the potential energy function, must be a map from R -> R
    vacua : list-like or None
        List of vacua of the potential energy.
    """

    def __init__(
        self,
        V: Callable[[float], float], # Yup - you can pass functions are argument in python!
        dV: Callable[[float], float],
        vacua: list | np.ndarray | None = None,  # np.ndarray is the type of a numpy array
    ):
        self.V = V
        self.dV = dV
        self.vacua = vacua

        if vacua is not None:
            for vacuum in vacua:
                # np.isclose does what it sounds like: are the values close?
                # That f"" is called an f-string, allowing you to add parameters to strings
                assert np.isclose(dV(vacuum), 0), (
                    f"The given vacua do not satisfy dV({vacuum}) = 0"
                )
```

Use:

``` python
from solitons1d.soliton import Lagrangian
import numpy as np

def phi4_V(x):
    return 0.5*np.pow(1-np.pow(x,2),2)

def phi4_dV(x):
    return 2*np.pow(x,3) - 2*x

phi4_lagrangian = Lagrangian(V=phi4_V, dV=phi4_dV, vacua=[-1,1])
```

Possible improvements:

- Add an automatic differentiation package to compute `dV` from `V`.
- Allow for multiple fields, different metric terms, time (harder - do you need to make a TimeGrid??).
- Delete this and make it part of the `Soliton` class?? Is this an improvement, or not? Why?
- Add library of common Lagrangians, so that the user doesn't have to specify the potential every time.

Questions:

- Why put an `assert` where we did? Better as a test?
- Can you edit the example code so that the `assert` is triggered?

## Update the `Soliton` class

Time to update the `Soliton` class to use the `Grid` and `Lagrangian` classes. When initialising the soliton, we'll allow the user to specify an initial profile function: either by specifying a function or passing an array representing the initial profile. We'll add a `compute_energy` method, and do something a bit odd: create another function called `compute_energy_fast`. Roughly: the method in the class strips out what we need from the object and passes this to `compute_energy_fast`: this second function doesn't interact with the class at all and we can optimize the heck out of it later. This is THE KEY concept to get the benefits of: 1) Lovely user-friendly classes 2) FAST STUFF. For now, we won't implement the energy function, but we will set up the machinery to do it later.

``` python

class Soliton:
    """
    A class describing a Soliton.

    Parameters
    ----------
    grid : Grid
        The grid underpinning the soliton.
    lagrangian : Lagrangian
        The Lagrangian of the theory supporting the soliton.
    initial_profile_function : None | function
        The initial profile function, must be from R -> R. Optional.
    initial_profile : None | array-like
        The initial profile function as an array. Optional.
    """

    def __init__(
        self,
        grid: Grid,
        lagrangian: Lagrangian,
        initial_profile_function: Callable[[float], float] | None = None,
        initial_profile: np.ndarray | None = None,
    ):
        self.grid = grid
        self.lagrangian = lagrangian

        self.profile = np.zeros(grid.num_grid_points)

        assert (initial_profile_function is None) or (initial_profile is None), (
            "Please only specify `initial_profile_function` or `profile_function`"
        )

        if initial_profile_function is not None:
            self.profile = create_profile(self.grid.grid_points, initial_profile_function)
        else:
            self.profile = initial_profile

        self.energy = self.compute_energy()

    def compute_energy(self):
        """Computes the energy of a soliton, and stores this in `Soliton.energy`."""

        energy = compute_energy_fast(
            self.lagrangian.V,
            self.profile,
            self.grid.num_grid_points,
            self.grid.grid_spacing,
        )
        self.energy = energy

def compute_energy_fast(V, profile, num_grid_points, grid_spacing):

    total_energy = 0
    return total_energy


def create_profile(
    grid_points: np.array,
    initial_profile_function: Callable[[np.array], np.array] | None = None,
) -> np.array:
    """
    Creates a profile function on a grid, from profile function `initial_profile_function`.

    Parameters
    ----------
    grid_points: Grid
        The x-values of a grid.
    initial_profile_function: function
        A function which accepts and returns a 1D numpy array

    Returns
    -------
    profile: np.array
        Generated profile function
    """

    profile = initial_profile_function(grid_points)
    return profile
```

Example code:

``` python
from solitons1d.soliton import Lagrangian, Grid, Soliton
import numpy as np

def phi4_V(x):
    return 0.5*np.pow(1-np.pow(x,2),2)

def phi4_dV(x):
    return 2*np.pow(x,3) - 2*x

phi4_lagrangian = Lagrangian(V=phi4_V, dV=phi4_dV, vacua=[-1,1])
my_grid = Grid(20,0.1)

my_soliton = Soliton(my_grid, phi4_lagrangian, initial_profile_function=np.tanh)

print(my_soliton.profile)
```

Improvements:

- If a user passes an `initial_profile`, check it's the right length.

Questions:

- What are all these `self`s about??
- Can you trigger the `assert` by playing with the example code?
- Before going on to the next section: try to write the `compute_energy_fast` function, or part of it.
- We've edited the `create_profile` function to fit in with our class. How has it changed? Why?


# Derivatives and Energy

To compute the energy, and the gradient flow, we'll need to compute derivatives. There are many ways to do this. The most common in the soliton field is using a finite difference method. Here, we implement the approximation

$$
\phi'(x) = \lim_{\epsilon \to 0}\frac{\phi(x+\epsilon) - \phi(x-\epsilon)}{2\epsilon}
$$

on our rigid grid. This can be approximated in many ways. You get more accuracy if you use more points. But if your true function does change fast and your points are too widely spread you'll hit numerical blow-ups. For solitons, I usually use a fourth-accuracy method. If we use `i` to denote the lattice point, the fourth order derivative approximates the derivative on the grid as follows:

$$
(\partial \phi)_i = \frac{1}{12}\phi_{i-2} - \frac{2}{3}\phi_{i-1} + \frac{2}{3}\phi_{i+1} - \frac{1}{12}\phi_{i+2}
$$

You can find other accuracies on [Wikipedia](https://en.wikipedia.org/wiki/Finite_difference_coefficient).

The big problem is the boundary. When we try to compute the derivative at the `0`th point, it tries to access the `-1`th point, which doesn't exist. Here are a few solutions:

- Use Dirichlet boundary conditions. So keep the boundary fixed. Since you're keeping it fixed, you don't need to update it and hence you don't need to compute the derivative there. Easy!
- Use forward/backwards finite difference to approximate the boundary points.
- Use Neumann boundary conditions. Keep the derivative equal to zero. If you do this, then at the boundary you can set $phi_{-1} = \phi_{1}$ and $\phi_{-2} = \phi_2$, and you don't need to worry.
- Use (possibly shifted) periodic boundary conditions, so that $\phi_{-1} = \phi_{N}$ and $\phi_{-2} = \phi_{N-1}$.

We're going to do the simples: Dirichlet. A good exercise for you: implement something else.

So, we'll write functions to compute the first and (while we're at it) second derivatives of a function. (This is going to be a FAST function, so we don't want it to interact with the class):

``` python
def get_first_derivative(
    phi: np.ndarray, 
    num_grid_points: int, 
    grid_spacing: float,
) -> np.ndarray:
    """
    For a given array, computes the first derivative of that array.

    Parameters
    ----------
    phi: np.ndarray
        Array to get the first derivative of
    num_grid_points: int
        Length of the array
    grid_spacing: float
        Grid spacing of underlying grid

    Returns
    -------
    d_phi: np.ndarray
        The first derivative of `phi`.

    """
    d_phi = np.zeros(num_grid_points)
    for i in np.arange(num_grid_points)[2:-2]:
        d_phi[i] = (phi[i - 2] - 8 * phi[i - 1] + 8 * phi[i + 1] - phi[i + 2]) / (
            12.0 * grid_spacing
        )

    return d_phi


def get_second_derivative(
    phi: np.ndarray, 
    num_grid_points: int, 
    grid_spacing: float,
) -> np.ndarray:
    """
    For a given array, computes the first derivative of that array.

    Parameters
    ----------
    phi: np.ndarray
        Array to get the first derivative of
    num_grid_points: int
        Length of the array
    grid_spacing: float
        Grid spacing of underlying grid

    Returns
    -------
    d_phi: np.ndarray
        The first derivative of `phi`.

    """
    ddV = np.zeros(num_grid_points)
    for i in np.arange(num_grid_points)[2:-2]:
        ddV[i] = (
            -phi[i - 2] + 16 * phi[i - 1] - 30 * phi[i] + 16 * phi[i + 1] - phi[i + 2]
        ) / (12.0 * np.pow(grid_spacing, 2))

    return ddV

```

With these derivative functions, computing the energy is easy. We just estimate the integral as a sum,

$$
E = \int \mathcal{E}(x) dx \approx (\Delta x)\sum_i \mathcal{E}_i \, ,
$$

like so:

``` python
def compute_energy_fast(
    V: Callable[[float], float],
    profile: np.array, 
    num_grid_points: int, 
    grid_spacing: float,
) -> float:
    """
    Computes the energy of a Lagrangian of the form
        E = 1/2 (d_phi)^2 + V(phi)

    Parameters
    ----------
    V: function
        The potential energy function
    profile: np.ndarray
        The profile function of the soliton
    num_grid_points: int
        Length of `profile`
    grid_spacing: float
        Grid spacing of underlying grid
    """
    dx_profile = get_first_derivative(profile, num_grid_points, grid_spacing)

    kin_eng = 0.5 * np.pow(dx_profile, 2)
    pot_eng = V(profile)

    tot_eng = np.sum(kin_eng + pot_eng) * grid_spacing

    return tot_eng
```

Example code, following on from last time

``` python
my_soliton.compute_energy()
print(my_soltion.energy)
```

Improvements:

- Allow for any type of boundary conditions
- Allow for any kind of kinetic energy

Questions:
- You could get `num_grid_points` by computing `len(profile)`. How would this improve your code? How would this make your code worse?

# Plot a Soliton

We're now making and computing solitons - let's take a look at what we're plotting. The most popular plotting package in Python is matplotlib. We need to install it by navigating to our Project folder in Terminal and running `uv add matplotlib`. In matplotlib, you've got a `Figure` which contains `Axes`. You can plot stuff on an `axis`, and adjust ticks and titles. Our code will look like:

``` python
import matplotlib.pyplot as plt
fig, ax = plt.subplots()
ax.plot(x,y)
ax.set_title("hello!")
```

And it makes sense and WE LOVE IT. When you Google matplotlib you'll find lots of code that looks like `plt.plot(x,y); plt.show()`. WE HATE THIS!!!! (ask me about it later)

So, the plan is to make a plotting method of the `Soliton` class that will return a matplotlib figure. It's nice to play with plotting in a Jupyter notebook. Here's my attempt at a reasonable plotting method. This is a method of the class, so should be indented in the class:

``` python
    def plot_soliton(self):
        """Makes a plot of the profile function of your soliton"""

        fig, ax = plt.subplots()
        ax.plot(self.grid.grid_points, self.profile)
        ax.set_title(f"Profile function. Energy = {self.energy:.4f}")

        return fig
```

Code example, following on from earlier:

``` python
# this should display in a Jupyter notebook, if you run it by itself
fig = my_soliton.plot_soliton()
fig.savefig("my_lovely_soliton.pdf")
```

# Save/load a Soliton

Coming soon...

# Gradient flow

Exercise: Write a gradient flow function, which the user can use as follows:

``` python
print(f"Energy before flow: {my_soliton.energy}")
my_soliton.gradient_flow(steps=1000, dt=0.0001)
my_soliton.compute_energy()
print(f"Energy after flow: {my_soliton.energy}")
```

You'll actually write two functions: a `gradient_flow` method in the `Soltion` class and a `gradient_flow_fast` function in the body of the code.

**End of "core" course**

# Bonus - coming soon

Including...

## Timing and Optimization
## Tests
## Documentation
## Linters, formatters and LSPs
## Continuous Integration
## Recommended Reading

