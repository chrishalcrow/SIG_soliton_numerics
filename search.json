[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "",
    "text": "Software engineering is now an integral part of science. As mathematicians and physicists, we’re pretty good at understanding algorithms, and even implementing them. But to ensure our code is easy to use, sharable, reproducible, tested and reliable we need to do a lot more than implement an algorithm. Modern software development involves continuous integration, linters, typers, LSPs, code coverage, automatically-generated docs, and more!\nThis course will focus on these “soft skills” of software. As such, we’ll be spending a lot of time setting up our project and development environment and thinking about our workflow. Then once we get to coding itself, we’ll go through that quite quickly.\nThese notes are designed to be self contained. You can start the course RIGHT NOW. You can suggest edits and raise issues on the GitHub page.\n\n\nWe have four sessions. In each one, I’ll give a brief introduction to the topic, then you will follow the notes and try and get some code working. If you’d like to spend this time simply working on your existing code: go for it!\nBy the end of the course, we’ll have made a small package to create a one-dimensional soliton and apply a flow to it. This is not scientifically revolutionary, but the code we make will have many good practices built into it. It will have tests and documentation. It’ll be readable, reproducible and published openly on GitHub. With this structure, I hope you can use this project as a base for future work.\nSo that everyone has the same experience, we’ll be using Python. If you’d prefer to use a different language, go for it! You’ll have to translate the Python code/concepts here into your favorite language, but that shouldn’t be too hard. C++, Julia and Matlab are all reasonable choices. We will use Python because it’s quite easy to get started with and it’s the most popular (and employable) language in the world. Python is traditionally thought to be slow, and it can be. But if you know how it works it can be just as fast as any other language. I also recommend writing the code in VSCode or PyCharm."
  },
  {
    "objectID": "index.html#plan-for-the-course-in-krakow",
    "href": "index.html#plan-for-the-course-in-krakow",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "",
    "text": "We have four sessions. In each one, I’ll give a brief introduction to the topic, then you will follow the notes and try and get some code working. If you’d like to spend this time simply working on your existing code: go for it!\nBy the end of the course, we’ll have made a small package to create a one-dimensional soliton and apply a flow to it. This is not scientifically revolutionary, but the code we make will have many good practices built into it. It will have tests and documentation. It’ll be readable, reproducible and published openly on GitHub. With this structure, I hope you can use this project as a base for future work.\nSo that everyone has the same experience, we’ll be using Python. If you’d prefer to use a different language, go for it! You’ll have to translate the Python code/concepts here into your favorite language, but that shouldn’t be too hard. C++, Julia and Matlab are all reasonable choices. We will use Python because it’s quite easy to get started with and it’s the most popular (and employable) language in the world. Python is traditionally thought to be slow, and it can be. But if you know how it works it can be just as fast as any other language. I also recommend writing the code in VSCode or PyCharm."
  },
  {
    "objectID": "index.html#the-terminal",
    "href": "index.html#the-terminal",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "3.1 The terminal",
    "text": "3.1 The terminal\nThe terminal is a nice way to interact with your computer. If you’re using Mac or Linux you have a terminal installed already. It’s called Terminal. If you have Windows, you have Powershell. So that everyone has a similar experience, I encourage you to install Windows Terminal (there are installation instructions on its GitHub page\nOpen your terminal and type “ls” (short for “list”) then press enter. This will display all the files in your currently directory. If you want to change directories type “cd” followed by the name of the directroy you want to go to."
  },
  {
    "objectID": "index.html#uv-to-install-python-packages",
    "href": "index.html#uv-to-install-python-packages",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "3.2 uv (to install python + packages)",
    "text": "3.2 uv (to install python + packages)\nPython’s biggest asset (and liability) is that people write packages for it. There are over 600,000 packages available on PyPi. These packages usually depend on each other, and it can get overwhelming keeping track. As such, we’ll use a installation/package manager called uv. This will install python and the packages for us, and help initialise our project. To install uv follow the instructions on uv’s website. Check it works by opening a Terminal (on Mac or Linux) and typing uv.\nOnce you have uv, you can run python in the terminal by typing uv run python. The first time you do this uv might install Python. So it might take a little minute."
  },
  {
    "objectID": "index.html#an-editor",
    "href": "index.html#an-editor",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "3.3 An editor",
    "text": "3.3 An editor\nA good text editor really helps coding. A good one allows you to search through codebases, auto-complete code, and more. I recommend VSCode because it’s free and has really good Python support. Some people love PyCharm. Please install one.\nBoth VScode and PyCharm have lots of extensions. For VSCode, please install the Python extension."
  },
  {
    "objectID": "index.html#git",
    "href": "index.html#git",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "3.4 Git",
    "text": "3.4 Git\nCheck that you have git installed by typing ‘git’ then pressing enter in your Terminal. It’s hopefully already installed. If not, please install it This is a good moment to make a https://github.com/."
  },
  {
    "objectID": "index.html#virtual-enviroments",
    "href": "index.html#virtual-enviroments",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "4.1 Virtual Enviroments",
    "text": "4.1 Virtual Enviroments\nOk, I’ve been sweeping the following topic under the rug but it’s very important to understand: virtual enviroments. Because python has so many packages and their dependencies are complex, it’s considered good behaviour to make a different enviroment for different projects. So you might have one enviroment for when you do statistics, one for when you do heavy numerical stuff and another for plotting. uv takes this to the extreme: it makes a new virtual enviroment every time you run python. When we ran uv run code . it make a folder called .venv containing the information about the enviroment. Then it opened VSCode and told it that we’re using this enviroment. This means VSCode is aware of which packages we’ve installed. This is gonna be super helpful later.\nLet’s add some package dependencies to our package. In the terminal, navigate to your project folder. We’ll add the package numpy by running uv add numpy. This will add numpy to the project by adding it to the pyproject.toml file.\nYou might notice another new file in your project folder called uv.lock. This keeps all the intricate details about the packages. It’s gross."
  },
  {
    "objectID": "index.html#functions",
    "href": "index.html#functions",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "7.1 Functions",
    "text": "7.1 Functions\nLet’s make a function. Functions take some input and return some output. Let’s make a create_profile function which will generate a profile for a 1D soliton. For now, we’ll just return an array of 0s:\nimport numpy as np\n\ndef create_profile(num_grid_points):\n    profile = np.zeros(num_grid_points)\n    return profile\nI’ll write this out in English:\n\n“Import the package called numpy and call it np, which is how we’ll be able to access it.”\n“Define a function called create_profile, which will accept the argument num_grid_points.”\n“Use the function zeros from the numpy library. (This will create an array of zeros). Assign this array of zeros to the variable profile.”\n“Return the variable profile. This return signals the end of the function\n\nThere are several improvements we can make to code immediately, we can: add type information about the arguments and returned parameter; add a docstring describing the function.\nimport numpy as np\n\ndef create_profile(num_grid_points: int) -&gt; np.array:\n    \"\"\"\n    Creates a profile function for a grid with \n    `num_grid_points` points.\n\n    Parameters\n    ----------\n    num_grid_points: int\n        Number of grid points\n\n    Returns\n    -------\n    profile: np.array\n        Generated profile function \n    \"\"\"\n\n    profile = np.zeros(num_grid_points)\n    return profile\nOk. Let’s use this function. We’re going to use play.ipynb. This is a Jupyter notebook. To use it, we need to install another package to our enviroment. In the terminal, navigate to the project folder, type “uv add ipykernel” then press enter. Now open play.ipynb in VSCode.\nA Jupyter notebook allows you to run little snippets of code in a “cell”. We need to import our function from our package, then run it. Put this code in your first cell\nfrom solitons1d.soliton import create_profile\nprofile = create_profile(100)\nprofile\nand execute this (either by pressing the “play” button next to the cell or pressing shift+enter). The final line of the cell gets displayed underneate it. So we should see a large array of 0s."
  },
  {
    "objectID": "index.html#classes-and-methods",
    "href": "index.html#classes-and-methods",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "7.2 Classes and methods",
    "text": "7.2 Classes and methods\nFunctions are fine. But classes are the heart of object-orientated programming. Think of a class as an abstract definition like a Group (from Group Theory). Then we can create objects which conform to the class definition (like we can create \\(D_4\\), a specific example of a group). In src/soliton.py, let’s make a class which will represent a soliton. When you make a specific instance of a class (object), it is “initialised”. During initialisation, we can choose what information to store in the object.\nclass Soliton():\n\n    def __init__(self, num_grid_points, grid_spacing):\n         self.num_grid_points = num_grid_points\n         self.grid_spacing = grid_spacing\n         self.profile = create_profile(num_grid_points)\nIn English:\n\n“Define a class called Soliton”\n“Define the initialisation method, which will accept two numbers, the number of grid points and the grid spacing.”\n“store the number of grid points”\n“store the grid spacing”\n“Make a profile function using the create_profile function and store it in profile.\n\nNow, back in your script, make a Soliton object:\nfrom solitons1d import Soliton\nmy_soliton = Soliton(100,0.1)\nprint(my_soliton.num_grid_points)\n\n“from the solitons1d package, import the class Soliton”\n“use the Soliton class to initialise a soliton with 100 grid points and 0.1 grid spacing called my_soliton”\n“take the soliton I just made, and get the number of grid points. Print this.”\n\nGreat! Hopefully you can see that it’s helpful to have an object that contains some information."
  },
  {
    "objectID": "index.html#methods",
    "href": "index.html#methods",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "7.3 Methods",
    "text": "7.3 Methods\nEven more helpful: write class-specific functions that can change what’s in the object. These are called “methods”. They’re similar to functions but are designed to only be applied to the class. These are defined in the class definition itself. Let’s create a method which will (eventually) compute the energy of the soliton. The Soliton class method get updated to the following:\nclass Soliton():\n\n    def __init__(self, num_grid_points, grid_spacing):\n         self.lp = num_grid_points\n         self.ls = grid_spacing\n         self.profile = create_profile(num_grid_points)\n\n    def compute_energy(self)\n\n         total_energy = np.sum(self.profile)\n         total_energy *= self.ls\n         self.energy = total_energy\nNow we have a method that takes in the profile function, sums it up, multiplies this value by the grid spacing, stores the value in self.energy then returns this value. We can use it in a script as follows:\nmy_soliton.compute_energy()\nprint(my_soliton.energy)\nWe’ve now got the basic building block that we’ll use for the rest of the course."
  },
  {
    "objectID": "index.html#upload-to-github",
    "href": "index.html#upload-to-github",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "7.4 Upload to GitHub",
    "text": "7.4 Upload to GitHub\nNow that we have a few functions, methods, and classes: let’s sync our local folder with our GitHub repository. You can do this using the Terminal (), but VSCode has some great Git integration. So let’s use that. Find the “Source Control” button in VSCode. When you press it, it should show a list of files that you have made changes to. The logic is:\n\n“Stage” the files you want to upload to GitHub. Do this by selecting the files you want to stage, right-clicking, then choosing “Stage Files”.\nCommit and Push the staged files to GitHub. Do this by first writing a message in the Message box. Maybe “Added Soliton class”. Then press the down arrow at the right hand side of the commit button, and click “Commit and Push”.\n\nThe first time you do this, you might need to Publish your branch. Every other time, it’s just the 2-step process above.\nNow go to your github page (mine is github.com/chrishalcrow/solitons1d/) and see if your changes have appeared there."
  },
  {
    "objectID": "index.html#the-grid-class",
    "href": "index.html#the-grid-class",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "8.1 The Grid class",
    "text": "8.1 The Grid class\nA user can create a grid by specifying the number of grid points and the grid spacing. The Grid will then compute a grid (saved as numpy array) and save the length of the grid.\nAdd this to soliton.py:\nimport numpy as np\n\nclass Grid:\n    \"\"\"\n    A 1D grid.\n\n    Parameters\n    ----------\n    num_grid_points : int\n        Number of grid points used in grid.\n    grid_spacing : float\n        Spacing between grid points.\n\n    Attributes\n    ----------\n    grid_length : float\n        Total length of grid.\n    grid_points : np.array[float]\n        An array of grid points, of the grid.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        num_grid_points: int,\n        grid_spacing: float,\n    ):\n        self.num_grid_points = num_grid_points\n        self.grid_spacing = grid_spacing\n        self.grid_length = (num_grid_points) * grid_spacing\n\n        self.grid_points = np.arange(\n            -self.grid_length / 2, self.grid_length / 2, grid_spacing\n        )\nPossible improvements:\n\nAllow the user to specify the grid in other ways: by providing the start and end points, for example. Question: How do you make the code flexible to allow the user to do several different things. Hint: If num_grid_points is None:\n\nQuestion:\n\nWhat’s the difference between a Parameter and an Attribute?\n\nUse. Make a grid as follow in a script:\nfrom solitons1d.soliton import Grid\nmy_grid = Grid(200,0.1)"
  },
  {
    "objectID": "index.html#make-a-lagrangian-class",
    "href": "index.html#make-a-lagrangian-class",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "8.2 Make a Lagrangian class",
    "text": "8.2 Make a Lagrangian class\nThe Lagrangian will keep track of the potential function. We won’t set up automatic differentiation, so we’ll also give the Lagrangian the derivative of the potential. We’ll also optionally allow the user to input the vacua of the theory. If they do, we’ll add a check that the derivative function of the vacua return 0. This class could also be where we define how many fields our theory has, any funny metric, and more. But let’s keep it simple for now.\nclass Lagrangian:\n    \"\"\"\n    Used to represent Lagrangians of the form:\n        L = - 1/2(dx_phi)^2 - V(phi)\n\n    Parameters\n    ----------\n    V : function\n        The potential energy function, must be a map from R -&gt; R\n    dV : function\n        The derivative of the potential energy function, must be a map from R -&gt; R\n    vacua : list-like or None\n        List of vacua of the potential energy.\n    \"\"\"\n\n    def __init__(\n        self,\n        V: Callable[[float], float], # Yup - you can pass functions are argument in python!\n        dV: Callable[[float], float],\n        vacua: list | np.ndarray | None = None,  # np.ndarray is the type of a numpy array\n    ):\n        self.V = V\n        self.dV = dV\n        self.vacua = vacua\n\n        if vacua is not None:\n            for vacuum in vacua:\n                # np.isclose does what it sounds like: are the values close?\n                # That f\"\" is called an f-string, allowing you to add parameters to strings\n                assert np.isclose(dV(vacuum), 0), (\n                    f\"The given vacua do not satisfy dV({vacuum}) = 0\"\n                )\nUse:\nfrom solitons1d.soliton import Lagrangian\nimport numpy as np\n\ndef phi4_V(x):\n    return 0.5*np.pow(1-np.pow(x,2),2)\n\ndef phi4_dV(x):\n    return 2*np.pow(x,3) - 2*x\n\nphi4_lagrangian = Lagrangian(V=phi4_V, dV=phi4_dV, vacua=[-1,1])\nPossible improvements:\n\nAdd an automatic differentiation package to compute dV from V.\nAllow for multiple fields, different metric terms, time (harder - do you need to make a TimeGrid??).\nDelete this and make it part of the Soliton class?? Is this an improvement, or not? Why?\nAdd library of common Lagrangians, so that the user doesn’t have to specify the potential every time.\n\nQuestions:\n\nWhy put an assert where we did? Better as a test?\nCan you edit the example code so that the assert is triggered?"
  },
  {
    "objectID": "index.html#update-the-soliton-class",
    "href": "index.html#update-the-soliton-class",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "8.3 Update the Soliton class",
    "text": "8.3 Update the Soliton class\nTime to update the Soliton class to use the Grid and Lagrangian classes. When initialising the soliton, we’ll allow the user to specify an initial profile function: either by specifying a function or passing an array representing the initial profile. We’ll add a compute_energy method, and do something a bit odd: create another function called compute_energy_fast. Roughly: the method in the class strips out what we need from the object and passes this to compute_energy_fast: this second function doesn’t interact with the class at all and we can optimize the heck out of it later. This is THE KEY concept to get the benefits of: 1) Lovely user-friendly classes 2) FAST STUFF. For now, we won’t implement the energy function, but we will set up the machinery to do it later.\n\nclass Soliton:\n    \"\"\"\n    A class describing a Soliton.\n\n    Parameters\n    ----------\n    grid : Grid\n        The grid underpinning the soliton.\n    lagrangian : Lagrangian\n        The Lagrangian of the theory supporting the soliton.\n    initial_profile_function : None | function\n        The initial profile function, must be from R -&gt; R. Optional.\n    initial_profile : None | array-like\n        The initial profile function as an array. Optional.\n    \"\"\"\n\n    def __init__(\n        self,\n        grid: Grid,\n        lagrangian: Lagrangian,\n        initial_profile_function: Callable[[float], float] | None = None,\n        initial_profile: np.ndarray | None = None,\n    ):\n        self.grid = grid\n        self.lagrangian = lagrangian\n\n        self.profile = np.zeros(grid.num_grid_points)\n\n        assert (initial_profile_function is None) or (initial_profile is None), (\n            \"Please only specify `initial_profile_function` or `profile_function`\"\n        )\n\n        if initial_profile_function is not None:\n            self.profile = create_profile(self.grid.grid_points, initial_profile_function)\n        else:\n            self.profile = initial_profile\n\n        self.energy = self.compute_energy()\n\n    def compute_energy(self):\n        \"\"\"Computes the energy of a soliton, and stores this in `Soliton.energy`.\"\"\"\n\n        energy = compute_energy_fast(\n            self.lagrangian.V,\n            self.profile,\n            self.grid.num_grid_points,\n            self.grid.grid_spacing,\n        )\n        self.energy = energy\n\ndef compute_energy_fast(V, profile, num_grid_points, grid_spacing):\n\n    total_energy = 0\n    return total_energy\n\n\ndef create_profile(\n    grid_points: np.array,\n    initial_profile_function: Callable[[np.array], np.array] | None = None,\n) -&gt; np.array:\n    \"\"\"\n    Creates a profile function on a grid, from profile function `initial_profile_function`.\n\n    Parameters\n    ----------\n    grid_points: Grid\n        The x-values of a grid.\n    initial_profile_function: function\n        A function which accepts and returns a 1D numpy array\n\n    Returns\n    -------\n    profile: np.array\n        Generated profile function\n    \"\"\"\n\n    profile = initial_profile_function(grid_points)\n    return profile\nExample code:\nfrom solitons1d.soliton import Lagrangian, Grid, Soliton\nimport numpy as np\n\ndef phi4_V(x):\n    return 0.5*np.pow(1-np.pow(x,2),2)\n\ndef phi4_dV(x):\n    return 2*np.pow(x,3) - 2*x\n\nphi4_lagrangian = Lagrangian(V=phi4_V, dV=phi4_dV, vacua=[-1,1])\nmy_grid = Grid(20,0.1)\n\nmy_soliton = Soliton(my_grid, phi4_lagrangian, initial_profile_function=np.tanh)\n\nprint(my_soliton.profile)\nImprovements:\n\nIf a user passes an initial_profile, check it’s the right length.\n\nQuestions:\n\nWhat are all these selfs about??\nCan you trigger the assert by playing with the example code?\nBefore going on to the next section: try to write the compute_energy_fast function, or part of it.\nWe’ve edited the create_profile function to fit in with our class. How has it changed? Why?"
  },
  {
    "objectID": "index.html#timing-and-optimization",
    "href": "index.html#timing-and-optimization",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "13.1 Timing and Optimization",
    "text": "13.1 Timing and Optimization"
  },
  {
    "objectID": "index.html#tests",
    "href": "index.html#tests",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "13.2 Tests",
    "text": "13.2 Tests"
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "13.3 Documentation",
    "text": "13.3 Documentation"
  },
  {
    "objectID": "index.html#linters-formatters-and-lsps",
    "href": "index.html#linters-formatters-and-lsps",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "13.4 Linters, formatters and LSPs",
    "text": "13.4 Linters, formatters and LSPs"
  },
  {
    "objectID": "index.html#continuous-integration",
    "href": "index.html#continuous-integration",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "13.5 Continuous Integration",
    "text": "13.5 Continuous Integration"
  },
  {
    "objectID": "index.html#recommended-reading",
    "href": "index.html#recommended-reading",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "13.6 Recommended Reading",
    "text": "13.6 Recommended Reading"
  }
]