[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "",
    "text": "Software engineering is now an integral part of science. As mathematicians and physicists, we’re pretty good at understanding algorithms, and even implementing them. But to ensure our code is easy to use, sharable, reproducible, tested and reliable we need to do a lot more than implement an algorithm. Modern software development involves continuous integration, linters, typers, LSPs, code coverage, automatically-generated docs, and more!\nThis course will focus on these “soft skills” of software. As such, we’ll be spending a lot of time on setting up our development environment and thinking about our workflow. Once we get to coding itself, we’ll go through that quite quickly.\nThese notes are designed to be self contained. You can start the course RIGHT NOW. You can suggest edits and raise issues on the GitHub page.\n\n\nWe have four sessions. In each one, I’ll give a brief introduction to the topic, then you will follow the notes and try and get some code working. If you’d like to spend this time simply working on your existing code: go for it!\nBy the end of the course, we’ll have made a small package to create a one-dimensional soliton and apply a flow to it. This is not scientifically revolutionary, but the code we make will have many good practices built into it. It will have tests and documentation. It’ll be readable, reproducible and published openly on GitHub. With this structure, I hope you can use this project as a base for future work.\nSo that everyone has the same experience, we’ll be using Python. If you’d prefer to use a different language, go for it! You’ll have to translate the Python code/concepts here into your favorite language, but that shouldn’t be too hard. C++, Julia and Matlab are all reasonable choices. We will use Python because it’s quite easy to get started with and it’s the most popular (and employable) language in the world. Python is traditionally thought to be slow, and it can be. But if you know how it works it can be just as fast as any other language. I also recommend writing the code in VSCode or PyCharm."
  },
  {
    "objectID": "index.html#plan-for-the-course-in-krakow",
    "href": "index.html#plan-for-the-course-in-krakow",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "",
    "text": "We have four sessions. In each one, I’ll give a brief introduction to the topic, then you will follow the notes and try and get some code working. If you’d like to spend this time simply working on your existing code: go for it!\nBy the end of the course, we’ll have made a small package to create a one-dimensional soliton and apply a flow to it. This is not scientifically revolutionary, but the code we make will have many good practices built into it. It will have tests and documentation. It’ll be readable, reproducible and published openly on GitHub. With this structure, I hope you can use this project as a base for future work.\nSo that everyone has the same experience, we’ll be using Python. If you’d prefer to use a different language, go for it! You’ll have to translate the Python code/concepts here into your favorite language, but that shouldn’t be too hard. C++, Julia and Matlab are all reasonable choices. We will use Python because it’s quite easy to get started with and it’s the most popular (and employable) language in the world. Python is traditionally thought to be slow, and it can be. But if you know how it works it can be just as fast as any other language. I also recommend writing the code in VSCode or PyCharm."
  },
  {
    "objectID": "index.html#the-terminal",
    "href": "index.html#the-terminal",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "The terminal",
    "text": "The terminal\nThe terminal is a nice way to interact with your computer. If you’re using Mac or Linux you have a terminal installed already. It’s called Terminal. If you have Windows, you have Powershell. So that everyone has a similar experience, I encourage you to install Windows Terminal (there are installation instructions on the GitHub page: https://docs.astral.sh/uv/#installation)\nOpen your terminal and type “ls” (short for “list”) then press enter. This will display all the files in your currently directory. If you want to change directories type “cd” followed by the name of the directroy you want to go to."
  },
  {
    "objectID": "index.html#uv-to-install-python-packages",
    "href": "index.html#uv-to-install-python-packages",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "uv (to install python + packages)",
    "text": "uv (to install python + packages)\nPython’s biggest asset (and liability) is that people write packages for it. There are over 600,000 packages available on PyPi (https://pypi.org). These packages usually depend on each other, and it can get overwhelming keeping track. As such, we’ll use a installation/package manager called uv. This will install python and the packages for us, and help initialise our project. To install uv follow the instructions on its website: https://docs.astral.sh/uv/#installation. Check it works by opening a Terminal (on Mac or Linux) and typing uv.\nOnce you have uv, you can run python in the terminal by typing uv run python. The first time you do this uv might install Python. So it might take a little minute."
  },
  {
    "objectID": "index.html#an-editor",
    "href": "index.html#an-editor",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "An editor",
    "text": "An editor\nA good text editor really helps coding. A good one allows you to search through codebases, auto-complete code, and more. I recommend VSCode (https://code.visualstudio.com/) because it’s free and has really good Python support. Some people love PyCharm (https://www.jetbrains.com/pycharm/). Please install one.\nBoth VScode and PyCharm have lots of extensions. For VSCode, please install the Python extension."
  },
  {
    "objectID": "index.html#git",
    "href": "index.html#git",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "Git",
    "text": "Git\nCheck that you have git installed by typing ‘git’ then pressing enter in your Terminal. It’s hopefully already installed. If not, please install it https://git-scm.com/book/en/v2/Getting-Started-Installing-Git This is a good moment to make a GitHub account too."
  },
  {
    "objectID": "index.html#virtual-enviroments",
    "href": "index.html#virtual-enviroments",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "Virtual Enviroments",
    "text": "Virtual Enviroments\nOk, I’ve been sweeping the following topic under the rug but it’s very important to understand: virtual enviroments. Because python has so many packages and their dependencies are complex, it’s considered good behaviour to make a different enviroment for different projects. So you might have one enviroment for when you do statistics, one for when you do heavy numerical stuff and another for plotting. uv takes this to the extreme: it makes a new virtual enviroment enviroment every time you run python. When we ran uv run code . it make a folder called .venv containing the information about the enviroment. And when we opened code uv told it that we’re using this enviroment. This means VSCode is aware of which packages we’ve installed. This is gonna be super helpful later.\nLet’s add some package dependencies to our package. In the terminal, navigate to your project folder. We’ll add the package numpy by running uv add numpy. This will add numpy to the project by adding it to the pyproject.toml file.\nYou might notice another new file in your project folder called uv.lock. This keeps all the intricate details about the packages. It’s gross."
  },
  {
    "objectID": "index.html#functions",
    "href": "index.html#functions",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "Functions",
    "text": "Functions\nLet’s make a function. Functions take some input and return some output. Let’s make a create_profile function which will generate a profile for a 1D soliton. For now, we’ll just return an array of 0s:\nimport numpy as np\n\ndef create_profile(num_lattice_points):\n    profile = np.zeros(num_lattice_points)\n    return profile\nI’ll write this out in English:\n\n“Import the package called numpy and call it np, which is how we’ll be able to access it.”\n“Define a function called create_profile, which will accept the argument num_lattice_points.”\n“Use the funcion zeros from the numpy library. (This will create an array of zeros). Assign this array of zeros to the variable profile.”\n“Return the variable profile. This return signals the end of the function\n\nThere are several improvements we can make to code immediately, we can: add type information about the arguments and returned parameter; add a docstring describing the function.\nimport numpy as np\n\ndef create_profile(num_lattice_points: int) -&gt; np.array:\n    \"\"\"\n    Creates a profile function for a lattice with \n    `num_lattice_points` points.\n\n    Parameters\n    ----------\n    num_lattice_points: int\n        Number of lattice points\n\n    Returns\n    -------\n    profile: np.array\n        Generated profile function \n    \"\"\"\n\n    profile = np.zeros(num_lattice_points)\n    return profile\nOk. Let’s use this function. We’re going to use investigate_soliton.ipynb. This is a Jupyter notebook. To use it, we need to add another package to our enviroment. In the terminal, navigate to the project folder, type “uv add ipykernel” then press enter. Ok, now open investigate_soliton.ipynb in VSCode.\nA Jupyter notebook allows you to run little snippets of code in a “cell”. We need to import our function from our package, then run it. Put this code in your first cell\nfrom solitons1d.soliton import create_profile\nprofile = create_profile(100)\nprofile\nand execute this (either by pressing the “play” button next to the cell or pressing shift+enter). The final line of the cell gets displayed underneate it. So we should see a large array of 0s."
  },
  {
    "objectID": "index.html#classes-and-methods",
    "href": "index.html#classes-and-methods",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "Classes and methods",
    "text": "Classes and methods\nFunctions are fine. But classes are the heart of object-orientated programming. A class represents an object. In src/soliton.py, let’s make a class which will represent a soliton. When you make an instance of a class (called an object), it is “initialised”. Here, we can choose what information to store in the object.\nclass Soliton():\n\n    def __init__(self, num_lattice_points, lattice_spacing):\n         self.lp = num_lattice_points\n         self.ls = lattice_spacing\n         self.profile = create_profile(num_lattice_points)\nIn English:\n\n“Define a class called Soliton”\n“Define the initialisation method, which will accept two integers, the number of lattice points and the lattice spacing.”\n“store the number of lattice points”\n“store the lattice_spacing”\n“Make a profile using the create_profile function and store it in profile.\n\nNow, back in your script, make a Soliton object:\nfrom solitons1d import Soliton\nmy_soliton = Soliton(100,0.1)\nprint(my_soliton.lp)\n\n“from the solitons1d package, import the class Soliton”\n“use the Soliton class to initialise a soliton with 100 lattice points and 0.1 lattice spacing called my_soliton”\n“take the soliton I just made, and get the number of lattice points. Print this.”\n\nGreat! Hopefully you can see that it’s helpful to have an object that contains some information."
  },
  {
    "objectID": "index.html#methods",
    "href": "index.html#methods",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "Methods",
    "text": "Methods\nEven more helpful: write class-specific functions that can change what’s in the object. These are called “methods”. They’re similar to functions but are designed to only apply to the class. These are defined in the class definition itself. Let’s create a method which will (eventually) compute the energy of the soliton. The Soliton class method get updated to the following:\nclass Soliton():\n\n    def __init__(self, num_lattice_points, lattice_spacing):\n         self.lp = num_lattice_points\n         self.ls = lattice_spacing\n         self.profile = create_profile(num_lattice_points)\n\n    def compute_energy(self)\n\n         total_energy = np.sum(self.profile)\n         total_energy *= self.ls\n         self.energy = total_energy\nNow we have a method that takes in the profile function, sums it up, multiplies this value by the lattice spacing, stores the value in self.energy then returns this value. We can use it in a script as follows:\nmy_soliton.compute_energy()\nprint(my_soliton.energy)\nWe’ve now got the basic building block that we’ll use for the rest of the course. Let’s now do a bunch of coding…"
  },
  {
    "objectID": "index.html#lots-of-code",
    "href": "index.html#lots-of-code",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "Lots of code!",
    "text": "Lots of code!\n6.1 Make a Lagrangian class\n6.2 Make a Grid class\n6.3 Update the Soliton class\n6.4 Make an initial profile function\n\n\nCompute the energy\n\nOk, let’s slow down to compute the energy"
  }
]