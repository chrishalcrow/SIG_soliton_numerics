[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "",
    "text": "Software engineering is now an integral part of science. As mathematicians and physicists, we’re pretty good at understanding algorithms, and even implementing them. But to ensure our code is easy to use, sharable, reproducible, tested and reliable we need to do a lot more than implement an algorithm. Modern software development involves continuous integration, linters, typers, LSPs, code coverage, automatically-generated docs, and more!\nThis course will focus on these “soft skills” of software. As such, we’ll be spending a lot of time setting up our project and development environment and thinking about our workflow. Then once we get to coding itself, we’ll go through that quite quickly.\nThese notes are designed to be self contained. You can start the course RIGHT NOW. You can suggest edits and raise issues on the GitHub page.\n\n\nWe have four sessions. In each one, I’ll give a brief introduction to the topic, then you will follow the notes and try and get some code working. If you’d like to spend this time simply working on your existing code: go for it!\nBy the end of the course, we’ll have made a small package to create a one-dimensional soliton and apply a flow to it. This is not scientifically revolutionary, but the code we make will have many good practices built into it. It will have tests and documentation. It’ll be readable, reproducible and published openly on GitHub. With this structure, I hope you can use this project as a base for future work.\nSo that everyone has the same experience, we’ll be using Python. If you’d prefer to use a different language, go for it! You’ll have to translate the Python code/concepts here into your favorite language, but that shouldn’t be too hard. C++, Julia and Matlab are all reasonable choices. We will use Python because it’s quite easy to get started with and it’s the most popular (and employable) language in the world. Python is traditionally thought to be slow, and it can be. But if you know how it works it can be just as fast as any other language. I also recommend writing the code in VSCode or PyCharm.\n\n\n\n\nBefore the course:\n\n\nInstallation\n\n\nMonday\n\n\nMake a Project\nGit and GitHub\n\n\nTuesday\n\n\nSource and scripts\nFunctions, classes and methods &lt;– coding only begins here!!\nLots of code!\n\n\nThursday\n\n\nCompute derivatives and the energy\nPlot a soliton\nSave/Load a soliton\n\n\nFriday\n\n\nGradient flow\n\n\nBonus\n\n\nTests\nDocumentation\nOptimization\nLinters, formatters and LSPs\nContinuous Integration\nRecommended Reading"
  },
  {
    "objectID": "index.html#plan-for-the-course-in-krakow",
    "href": "index.html#plan-for-the-course-in-krakow",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "",
    "text": "We have four sessions. In each one, I’ll give a brief introduction to the topic, then you will follow the notes and try and get some code working. If you’d like to spend this time simply working on your existing code: go for it!\nBy the end of the course, we’ll have made a small package to create a one-dimensional soliton and apply a flow to it. This is not scientifically revolutionary, but the code we make will have many good practices built into it. It will have tests and documentation. It’ll be readable, reproducible and published openly on GitHub. With this structure, I hope you can use this project as a base for future work.\nSo that everyone has the same experience, we’ll be using Python. If you’d prefer to use a different language, go for it! You’ll have to translate the Python code/concepts here into your favorite language, but that shouldn’t be too hard. C++, Julia and Matlab are all reasonable choices. We will use Python because it’s quite easy to get started with and it’s the most popular (and employable) language in the world. Python is traditionally thought to be slow, and it can be. But if you know how it works it can be just as fast as any other language. I also recommend writing the code in VSCode or PyCharm."
  },
  {
    "objectID": "index.html#detailed-plan",
    "href": "index.html#detailed-plan",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "",
    "text": "Before the course:\n\n\nInstallation\n\n\nMonday\n\n\nMake a Project\nGit and GitHub\n\n\nTuesday\n\n\nSource and scripts\nFunctions, classes and methods &lt;– coding only begins here!!\nLots of code!\n\n\nThursday\n\n\nCompute derivatives and the energy\nPlot a soliton\nSave/Load a soliton\n\n\nFriday\n\n\nGradient flow\n\n\nBonus\n\n\nTests\nDocumentation\nOptimization\nLinters, formatters and LSPs\nContinuous Integration\nRecommended Reading"
  },
  {
    "objectID": "index.html#the-terminal",
    "href": "index.html#the-terminal",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "1.1 The terminal",
    "text": "1.1 The terminal\nThe terminal is a nice way to interact with your computer. If you’re using Mac or Linux you have a terminal installed already. It’s called Terminal. If you have Windows, you have Powershell. So that everyone has a similar experience, I encourage you to install Windows Terminal (there are installation instructions on its GitHub page\nOpen your terminal and type “ls” (short for “list”) then press enter. This will display all the files in your currently directory. If you want to change directories type “cd” followed by the name of the directroy you want to go to."
  },
  {
    "objectID": "index.html#uv-to-install-python-packages",
    "href": "index.html#uv-to-install-python-packages",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "1.2 uv (to install python + packages)",
    "text": "1.2 uv (to install python + packages)\nPython’s biggest asset (and liability) is that people write packages for it. There are over 600,000 packages available on PyPi. These packages usually depend on each other, and it can get overwhelming keeping track. As such, we’ll use a installation/package manager called uv. This will install python and the packages for us, and help initialise our project. To install uv follow the instructions on uv’s website. Check it works by opening a Terminal (on Mac or Linux) and typing uv.\nOnce you have uv, you can run python in the terminal by typing uv run python. The first time you do this uv might install Python. So it might take a little minute."
  },
  {
    "objectID": "index.html#an-editor",
    "href": "index.html#an-editor",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "1.3 An editor",
    "text": "1.3 An editor\nA good text editor really helps coding. A good one allows you to search through codebases, auto-complete code, and more. I recommend VSCode because it’s free and has really good Python support. Some people love PyCharm. Please install one.\nBoth VScode and PyCharm have lots of extensions. For VSCode, please install the Python extension."
  },
  {
    "objectID": "index.html#git",
    "href": "index.html#git",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "1.4 Git",
    "text": "1.4 Git\nCheck that you have git installed by typing ‘git’ then pressing enter in your Terminal. It’s hopefully already installed. If not, please install it This is a good moment to make a GitHub account too."
  },
  {
    "objectID": "index.html#virtual-enviroments",
    "href": "index.html#virtual-enviroments",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "2.1 Virtual Enviroments",
    "text": "2.1 Virtual Enviroments\nOk, I’ve been sweeping the following topic under the rug but it’s very important to understand: virtual enviroments. Because python has so many packages and their dependencies are complex, it’s considered good behaviour to make a different enviroment for different projects. So you might have one enviroment for when you do statistics, one for when you do heavy numerical stuff and another for plotting. uv takes this to the extreme: it makes a new virtual enviroment every time you run python. When we ran uv run code . it make a folder called .venv containing the information about the enviroment. Then it opened VSCode and told it that we’re using this enviroment. This means VSCode is aware of which packages we’ve installed. This is gonna be super helpful later.\nNow we’ll add some packages to our project - this tells uv that when we create the virtual enviroment it should install these packages. In the terminal, navigate to your project folder. Add the package numpy by running uv add numpy. This will add numpy to the project by adding it to the pyproject.toml file."
  },
  {
    "objectID": "index.html#functions",
    "href": "index.html#functions",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "5.1 Functions",
    "text": "5.1 Functions\nLet’s make a function. Functions take some input and return some output. Let’s make a create_profile function which will generate a profile for a 1D soliton. For now, we’ll just return an array of 0s:\nimport numpy as np\n\ndef create_profile(num_grid_points):\n    profile = np.zeros(num_grid_points)\n    return profile\nI’ll write this out in English:\n\n“Import the package called numpy and call it np, which is how we’ll be able to access it.”\n“Define a function called create_profile, which will accept the argument num_grid_points.”\n“Use the function zeros from the numpy library. (This will create an array of zeros). Assign this array of zeros to the variable profile.”\n“Return the variable profile. This return signals the end of the function.\n\nThere are several improvements we can make to code immediately, we can: add type information about the arguments and returned parameters; add a docstring describing the function.\nimport numpy as np\n\ndef create_profile(num_grid_points: int) -&gt; np.array:\n    \"\"\"\n    Creates a profile function for a grid with \n    `num_grid_points` points.\n\n    Parameters\n    ----------\n    num_grid_points: int\n        Number of grid points\n\n    Returns\n    -------\n    profile: np.array\n        Generated profile function \n    \"\"\"\n\n    profile = np.zeros(num_grid_points)\n    return profile\nOk. Let’s use this function. We’re going to use play.ipynb. This is a Jupyter notebook. To use it, we need to install another package to our enviroment. In the terminal, navigate to the project folder, type “uv add ipykernel” then press enter. Now open play.ipynb in VSCode.\nA Jupyter notebook allows you to run little snippets of code in a “cell”. We need to import our function from our package, then run it. Put this code in your first cell\nfrom solitons1d.soliton import create_profile\nprofile = create_profile(100)\nprofile\nand execute this (either by pressing the “play” button next to the cell or pressing shift+enter). The final line of the cell gets displayed underneate it. So we should see a large array of 0s."
  },
  {
    "objectID": "index.html#classes-and-methods",
    "href": "index.html#classes-and-methods",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "5.2 Classes and methods",
    "text": "5.2 Classes and methods\nFunctions are fine. But classes are the heart of object-orientated programming. Think of a class as an abstract definition like a Group (from Group Theory). Then we can create objects which conform to the class definition (like we can create \\(D_4\\), a specific example of a group). In src/soliton.py, let’s make a class which will represent a soliton. When you make a specific instance of a class (object), it is “initialised”. During initialisation, we can choose what information to store in the object.\nclass Soliton():\n\n    def __init__(self, num_grid_points, grid_spacing):\n         self.num_grid_points = num_grid_points\n         self.grid_spacing = grid_spacing\n         self.profile = create_profile(num_grid_points)\nIn English:\n\n“Define a class called Soliton”\n“Define the initialisation method, which will accept two numbers, the number of grid points and the grid spacing.”\n“store the number of grid points”\n“store the grid spacing”\n“Make a profile function using the create_profile function and store it in profile.\n\nNow, back in your script, make a Soliton object:\nfrom solitons1d import Soliton\nmy_soliton = Soliton(100,0.1)\nprint(my_soliton.num_grid_points)\n\n“from the solitons1d package, import the class Soliton”\n“use the Soliton class to initialise a soliton with 100 grid points and 0.1 grid spacing called my_soliton”\n“take the soliton I just made, and get the number of grid points. Print this.”\n\nGreat! Hopefully you can see that it’s helpful to have an object that contains some information."
  },
  {
    "objectID": "index.html#methods",
    "href": "index.html#methods",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "5.3 Methods",
    "text": "5.3 Methods\nEven more helpful: write class-specific functions that can change what’s in the object. These are called “methods”. They’re similar to functions but are designed to only be applied to the class. These are defined in the class definition itself. Let’s create a method which will (eventually) compute the energy of the soliton. The Soliton class gets updated to the following:\nclass Soliton():\n\n    def __init__(self, num_grid_points, grid_spacing):\n         self.lp = num_grid_points\n         self.ls = grid_spacing\n         self.profile = create_profile(num_grid_points)\n\n    def compute_energy(self)\n\n         total_energy = np.sum(self.profile)\n         total_energy *= self.ls\n         self.energy = total_energy\nNow we have a method that takes in the profile function, sums it up, multiplies this value by the grid spacing, stores the value in self.energy then returns this value. We can use it in a script as follows:\nmy_soliton.compute_energy()\nprint(my_soliton.energy)\nWe’ve now got the basic building block that we’ll use for the rest of the course."
  },
  {
    "objectID": "index.html#upload-to-github",
    "href": "index.html#upload-to-github",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "5.4 Upload to GitHub",
    "text": "5.4 Upload to GitHub\nNow that we have a few functions, methods, and classes: let’s sync our local folder with our GitHub repository. You can do this using the Terminal (), but VSCode has some great Git integration. So let’s use that. Find the “Source Control” button in VSCode. When you press it, it should show a list of files that you have made changes to. The logic is:\n\n“Stage” the files you want to sync to GitHub. Do this by selecting the files you want to stage, right-clicking, then choosing “Stage Files”.\nCommit and Push the staged files to GitHub. Do this by first writing a message in the Message box. Maybe “Added Soliton class”. Then press the down arrow at the right hand side of the commit button, and click “Commit and Push”.\n\nThe first time you do this, you might need to Publish your branch. Every other time, it’s just the 2-step process above.\nNow go to your github page (mine is github.com/chrishalcrow/solitons1d/) and see if your changes have appeared there."
  },
  {
    "objectID": "index.html#the-grid-class",
    "href": "index.html#the-grid-class",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "6.1 The Grid class",
    "text": "6.1 The Grid class\nA user can create a grid by specifying the number of grid points and the grid spacing. The Grid will then compute a grid (saved as numpy array) and save the length of the grid.\nAdd this to soliton.py:\nimport numpy as np\n\nclass Grid:\n    \"\"\"\n    A 1D grid.\n\n    Parameters\n    ----------\n    num_grid_points : int\n        Number of grid points used in grid.\n    grid_spacing : float\n        Spacing between grid points.\n\n    Attributes\n    ----------\n    grid_length : float\n        Total length of grid.\n    grid_points : np.array[float]\n        An array of grid points, of the grid.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        num_grid_points: int,\n        grid_spacing: float,\n    ):\n        self.num_grid_points = num_grid_points\n        self.grid_spacing = grid_spacing\n        self.grid_length = (num_grid_points) * grid_spacing\n\n        self.grid_points = np.arange(\n            -self.grid_length / 2, self.grid_length / 2, grid_spacing\n        )\nPossible improvements:\n\nAllow the user to specify the grid in other ways: by providing the start and end points, for example. Question: How do you make the code flexible to allow the user to do several different things. Hint: If num_grid_points is None:\n\nQuestion:\n\nWhat’s the difference between a Parameter and an Attribute?\n\nUse. Make a grid as follow in a script:\nfrom solitons1d.soliton import Grid\nmy_grid = Grid(200,0.1)"
  },
  {
    "objectID": "index.html#make-a-lagrangian-class",
    "href": "index.html#make-a-lagrangian-class",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "6.2 Make a Lagrangian class",
    "text": "6.2 Make a Lagrangian class\nThe Lagrangian will keep track of the potential function. We won’t set up automatic differentiation, so we’ll also give the Lagrangian the derivative of the potential. We’ll also optionally allow the user to input the vacua of the theory. If they do, we’ll add a check that the derivative function of the vacua return 0. This class could also be where we define how many fields our theory has, any funny metric, and more. But let’s keep it simple for now.\nclass Lagrangian:\n    \"\"\"\n    Used to represent Lagrangians of the form:\n        L = - 1/2(dx_phi)^2 - V(phi)\n\n    Parameters\n    ----------\n    V : function\n        The potential energy function, must be a map from R -&gt; R\n    dV : function\n        The derivative of the potential energy function, must be a map from R -&gt; R\n    vacua : list-like or None\n        List of vacua of the potential energy.\n    \"\"\"\n\n    def __init__(\n        self,\n        V: Callable[[float], float], # Yup - you can pass functions are argument in python!\n        dV: Callable[[float], float],\n        vacua: list | np.ndarray | None = None,  # np.ndarray is the type of a numpy array\n    ):\n        self.V = V\n        self.dV = dV\n        self.vacua = vacua\n\n        if vacua is not None:\n            for vacuum in vacua:\n                # np.isclose does what it sounds like: are the values close?\n                # That f\"\" is called an f-string, allowing you to add parameters to strings\n                assert np.isclose(dV(vacuum), 0), (\n                    f\"The given vacua do not satisfy dV({vacuum}) = 0\"\n                )\nUse:\nfrom solitons1d.soliton import Lagrangian\nimport numpy as np\n\ndef phi4_V(x):\n    return 0.5*np.pow(1-np.pow(x,2),2)\n\ndef phi4_dV(x):\n    return 2*np.pow(x,3) - 2*x\n\nphi4_lagrangian = Lagrangian(V=phi4_V, dV=phi4_dV, vacua=[-1,1])\nPossible improvements:\n\nAdd an automatic differentiation package to compute dV from V.\nAllow for multiple fields, different metric terms, time (harder - do you need to make a TimeGrid??).\nDelete this and make it part of the Soliton class?? Is this an improvement, or not? Why?\nAdd library of common Lagrangians, so that the user doesn’t have to specify the potential every time.\n\nQuestions:\n\nWhy put an assert where we did? Better as a test?\nCan you edit the example code so that the assert is triggered?"
  },
  {
    "objectID": "index.html#update-the-soliton-class",
    "href": "index.html#update-the-soliton-class",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "6.3 Update the Soliton class",
    "text": "6.3 Update the Soliton class\nTime to update the Soliton class to use the Grid and Lagrangian classes. When initialising the soliton, we’ll allow the user to specify an initial profile function: either by specifying a function or passing an array representing the initial profile. We’ll add a compute_energy method, and do something a bit odd: create another function called compute_energy_fast. Roughly: the method in the class strips out what we need from the object and passes this to compute_energy_fast: this second function doesn’t interact with the class at all and we can optimize the heck out of it later. This is THE KEY concept to get the benefits of: 1) Lovely user-friendly classes 2) FAST STUFF. For now, we won’t implement the energy function, but we will set up the machinery to do it later.\n\nclass Soliton:\n    \"\"\"\n    A class describing a Soliton.\n\n    Parameters\n    ----------\n    grid : Grid\n        The grid underpinning the soliton.\n    lagrangian : Lagrangian\n        The Lagrangian of the theory supporting the soliton.\n    initial_profile_function : None | function\n        The initial profile function, must be from R -&gt; R. Optional.\n    initial_profile : None | array-like\n        The initial profile function as an array. Optional.\n    \"\"\"\n\n    def __init__(\n        self,\n        grid: Grid,\n        lagrangian: Lagrangian,\n        initial_profile_function: Callable[[float], float] | None = None,\n        initial_profile: np.ndarray | None = None,\n    ):\n        self.grid = grid\n        self.lagrangian = lagrangian\n\n        self.profile = np.zeros(grid.num_grid_points)\n\n        assert (initial_profile_function is None) or (initial_profile is None), (\n            \"Please only specify `initial_profile_function` or `profile_function`\"\n        )\n\n        if initial_profile_function is not None:\n            self.profile = create_profile(self.grid.grid_points, initial_profile_function)\n        else:\n            self.profile = initial_profile\n\n        self.energy = self.compute_energy()\n\n    def compute_energy(self):\n        \"\"\"Computes the energy of a soliton, and stores this in `Soliton.energy`.\"\"\"\n\n        energy = compute_energy_fast(\n            self.lagrangian.V,\n            self.profile,\n            self.grid.num_grid_points,\n            self.grid.grid_spacing,\n        )\n        self.energy = energy\n\ndef compute_energy_fast(V, profile, num_grid_points, grid_spacing):\n\n    total_energy = 0\n    return total_energy\n\n\ndef create_profile(\n    grid_points: np.array,\n    initial_profile_function: Callable[[np.array], np.array] | None = None,\n) -&gt; np.array:\n    \"\"\"\n    Creates a profile function on a grid, from profile function `initial_profile_function`.\n\n    Parameters\n    ----------\n    grid_points: Grid\n        The x-values of a grid.\n    initial_profile_function: function\n        A function which accepts and returns a 1D numpy array\n\n    Returns\n    -------\n    profile: np.array\n        Generated profile function\n    \"\"\"\n\n    profile = initial_profile_function(grid_points)\n    return profile\nExample code:\nfrom solitons1d.soliton import Lagrangian, Grid, Soliton\nimport numpy as np\n\ndef phi4_V(x):\n    return 0.5*np.pow(1-np.pow(x,2),2)\n\ndef phi4_dV(x):\n    return 2*np.pow(x,3) - 2*x\n\nphi4_lagrangian = Lagrangian(V=phi4_V, dV=phi4_dV, vacua=[-1,1])\nmy_grid = Grid(20,0.1)\n\nmy_soliton = Soliton(my_grid, phi4_lagrangian, initial_profile_function=np.tanh)\n\nprint(my_soliton.profile)\nImprovements:\n\nIf a user passes an initial_profile, check it’s the right length.\n\nQuestions:\n\nWhat are all these selfs about??\nCan you trigger the assert by playing with the example code?\nBefore going on to the next section: try to write the compute_energy_fast function, or part of it.\nWe’ve edited the create_profile function to fit in with our class. How has it changed? Why?"
  },
  {
    "objectID": "index.html#saveload-a-grid",
    "href": "index.html#saveload-a-grid",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "9.1 Save/Load a Grid",
    "text": "9.1 Save/Load a Grid\nThe Grid is an easy object to save and load because it can be reconstructed from just the number of lattice points and the lattice spacing. We first add a save method to the Grid class. This will involve some new “standard” packages: json and pathlib. The standard packages are packages with basic Python, so you don’t need to add them using uv.\n# add near the top of the file\nimport json\nfrom pathlib import Path\n\n# add to Grid class\n    def save(\n        self,\n        folder_name: str | Path,\n    ):\n        \"\"\"\n        Saves a `Grid` object at `folder_name`.\n        \"\"\"\n        metadata = {\n            \"num_grid_points\": self.num_grid_points,\n            \"grid_spacing\": self.grid_spacing\n        }\n\n        # make the folder a Path if it is a string\n        folder = Path(folder_name)\n        folder.mkdir(exist_ok = True)\n\n        # this overwrites any existing metadata.json file\n        with open(folder / \"metadata.json\", \"w\") as f:\n            json.dump(metadata, f)\nThe loading function is a function, not a method (why?). It should read the json file, make a Grid object and return it\ndef load_grid(folder_name: str | Path):\n    \"\"\"\n    Loads the `Grid` object at `folder_name`.\n    \"\"\"\n    folder = Path(folder_name)\n    metadata_path = folder / \"metadata.json\"\n\n    assert metadata_path.is_file(), f\"Could not find Grid `metadata.json` file in {folder}.\"\n    \n    with open(metadata_path, \"r\") as f:\n        grid_metadata = json.load(f)\n    \n    # the ** \"unpacks\" the dictionary into a series of arguments\n    grid = Grid(**grid_metadata)\n    return grid\nUsing it:\nfrom solitons1d.soliton import load_grid\n\nmy_grid = Grid(100,0.1)\nmy_grid.save(\"my_lovely_grid\")\nmy_loaded_grid = load_grid(\"my_lovely_grid\")"
  },
  {
    "objectID": "index.html#saveload-a-lagrangian",
    "href": "index.html#saveload-a-lagrangian",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "9.2 Save/Load a Lagrangian",
    "text": "9.2 Save/Load a Lagrangian\nThe Lagrangian is more complicated: we need a save the potential and the derivative of the potential, which are generic functions. We’ll do this using the pickle format, which can save any Python object (note: you could use this to save the full Soliton object).\nimport pickle as pkl\n\n# add to Lagrangian class\n\n    def save(\n        self,\n        folder_name: str | Path,\n    ):\n        \"\"\"\n        Saves a `Lagrangian` object at `folder_name`.\n        \"\"\"\n        metadata = {\n            \"V\": self.V,\n            \"dV\": self.dV,\n            \"vacua\": self.vacua,\n        }\n\n        # make the folder a Path if it is a string\n        folder = Path(folder_name)\n        folder.mkdir(exist_ok = True)\n\n        with open(folder / \"metadata.pkl\", \"wb\") as f:\n            pkl.dump(metadata, f)\n\n# add to main body\n\ndef load_lagrangian(folder_name: str | Path):\n    \"\"\"\n    Loads the `Lagrangian` object at `folder_name`.\n    \"\"\"\n    folder = Path(folder_name)\n    metadata_path = folder / \"metadata.pkl\"\n\n    assert metadata_path.is_file(), f\"Could not find Lagrangian `metadata.json` file in {folder}.\"\n    \n    with open(metadata_path, \"rb\") as f:\n        lagrangian_metadata = pkl.load(f)\n    \n    # the ** \"unpacks\" the dictionary into a series of arguments\n    lagrangian = Lagrangian(**lagrangian_metadata)\n    return lagrangian\nQuestions:\n\nSave a Lagrangian and a Grid, and take a look in the folder. Why might you prefer json to pickle?"
  },
  {
    "objectID": "index.html#saveload-a-soliton-1",
    "href": "index.html#saveload-a-soliton-1",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "9.3 Save/Load a Soliton",
    "text": "9.3 Save/Load a Soliton\nNow we want to save the Soliton, including any profile funciton we’ve made. Since we compute the energy on instantiation we’ll also save this as a property. Let’s go:\n    def save(\n        self,\n        folder_name: str | Path,\n    ):\n        \"\"\"\n        Saves a `Soliton` object at `folder_name`.\n        \"\"\"\n\n        folder = Path(folder_name)\n        folder.mkdir(exist_ok = True)\n\n        grid_folder =  \"./grid\"\n        lagrangian_folder = \"./lagrangian\"\n\n        metadata = {\n            'grid_folder': str(grid_folder),\n            'lagrangian_folder': str(lagrangian_folder),\n        }\n\n        properties = {\n            'energy': self.energy\n        }\n\n        self.grid.save(grid_folder)\n        self.lagrangian.save(lagrangian_folder)\n\n        with open(folder / \"metadata.json\", \"w\") as f:\n            json.dump(metadata, f)\n\n        with open(folder / \"properties.json\", \"w\") as f:\n            json.dump(properties, f)\n        \n        # use `numpy`s save function to save the profile array\n        np.save(\"profile\", self.profile)\n\n\ndef load_soliton(folder_name):\n    \"\"\"\n    Loads the `Lagrangian` object at `folder_name`.\n    \"\"\"\n    folder = Path(folder_name)\n    metadata_path = folder / \"metadata.json\"\n\n    assert metadata_path.is_file(), f\"Could not find Grid `metadata.json` file in {folder}.\"\n    \n    with open(metadata_path, \"r\") as f:\n        soliton_metadata = json.load(f)\n\n    grid_folder = soliton_metadata.get(\"grid_folder\")\n    grid = load_grid(grid_folder)\n\n    lagrangian_folder = soliton_metadata.get(\"lagrangian_folder\")\n    lagrangian = load_lagrangian(lagrangian_folder)\n\n    profile = np.load(\"profile.npy\")\n    \n    soliton = Soliton(grid = grid, lagrangian=lagrangian, initial_profile=profile)\n\n    return soliton\nExercise: save a soliton, and load it.\nNote: We’ve written more code to save and load our objects than we will to gradient flow them. Ouch."
  },
  {
    "objectID": "index.html#timing-and-optimization",
    "href": "index.html#timing-and-optimization",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "11.1 Timing and Optimization",
    "text": "11.1 Timing and Optimization\nOK! Here’s the big one. Let’s make our functions FAST.\nWe’ll do this using numba. Numba is a big-fry package: Nvidia use it for their python implemtation of CUDA (their GPU library). Roughly, when we “numbafy” a function, when the complier first sees the function it compiles it into highly-optimized C code. But it can only do this to certain functions. Roughly: it likes for loops and numpy functions. It hates strings, dictionaries and dataframes. More read here:\nBefore we make the code fast, let’s see how fast it is now. We’ll do the timing using the perf_counter from the time standard library. To really see a difference in 1D code we need to make a silly example. Let’s make a giant grid, then compute the derivative lots of times using get_first_derivative, and time it:\nfrom time import perf_counter\nfrom solitons1d.soliton import get_first_derivative\nimport numpy as np\n\narray_length = 100_000\nrandom_big_array = np.random.random(array_length)\n\ntimes = []\nfor _ in range(100):\n    t1 = perf_counter()\n    get_first_derivative(random_big_array, num_grid_points=array_length, grid_spacing=0.1)\n    t2 = perf_counter()\n    times.append(t2-t1)\n\nprint(np.median(times))\n&gt;&gt;&gt; 0.04206724999676226\nSo computing the derivative of a 100_000 long array took 0.04206724999676226 seconds.\nTo use numba we need to add it to our package (uv add numba) then “decorate” our get_first_derivative function using njit by doing the following in soliton.py:\nfrom numba import njit\n\n@njit\ndef get_first_derivative(\n    ...\nnjit means “no-python just-in-time compliation”. More: “when the compiler first meets this function, compile it just as you use it. Try to make pure C++ code. In fact, if you can’t do this and still have some python in it: throw an error!”.\nRestart your jupyter kernel, and rerun the timing script. I now get a time of 0.00010070799908135086 seconds, a speed-up of \\(\\times 420\\)!!!!!\nNow, the reason this worked so easily is because we set up the code structure so that numba would be easy to implement. Doing this from scratch is kinda difficult. Luckily, all our code is numba-fy-able. We just need to decorate lots of funcitons with @njit. I’ve added it to\n\ncompute_energy_fast\ngrad_flow_fast\nget_first_derivative\nget_second_derivative\ncompute_dE\n\nNote: you need to @njit the Lagrangian’s functions too when you make it.\nThe other functions and methods don’t need to be fast.\nnumba also allows for parallelisation if we tell if which loops are parallelisable. ALL of ours are!! We can tell it that they are parallelisable by using a prange (parallel range) in the for loop and by telling the @njit decorator that parallelisation is allowed. This takes a little bit of modifying… The get_first_derivative function now looks like:\n@njit(parallel=True)\ndef get_first_derivative(\n    phi: np.ndarray, \n    num_grid_points: int, \n    grid_spacing: float,\n) -&gt; np.ndarray:\n    d_phi = np.zeros(num_grid_points)\n    for i in prange(num_grid_points-4):\n        d_phi[i+2] = (phi[i] - 8 * phi[i + 1] + 8 * phi[i + 3] - phi[i + 4]) / (\n            12.0 * grid_spacing\n        )\n    return d_phi\nI get a x2 speed-up on my laptop (but to see the benefit clearly, I need to incease the lattice points to 10_000_000). Feel free to parallelise all your other fast functions too!\nNow that things are getting more complicated, it’s at least nice that the complicated stuff is contained in the get_first_derivative function. This mess isn’t leaking into the Soliton class code, or anything like that. It’s gross but we’ve localised it.\nSome more optimisation tips:\n\nAllocating memory is expensive. So d_phi = np.zeros(num_grid_points) costs time. We can save this time by preallocating this memory. Maybe we can keep a copy of d_profile and dd_profile in the Soliton class.\nInitialising the multi-threading happens when the for loop is called, and it expensive. Currently we do this once during get_first_derivative and again during dV(profile[i]) (if we turn this into a loop). It would be faster to only do this once. To do this our gradient flow code should look like\n\ndef compute_dE(...):\n    dE = np.zeros(points)\n    for i in prange(points):\n        dd_at_point = get_second_derivative_at_point(i)\n        dV_array = dV(profile[i])\n        dE[i] = dd_at_point - dV_array\nThis is harder than it sounds, because get_second_derivative_at_point depends on which point you’re looking at. At the boundary, you have to do something different. There are a few creative solutions to deal with this. Think about it, and feel free to talk to me about them.\n\nDon’t worry about little things. Modern compilers are smart. If you write something like\n\nmy_variable = 3\nreturn my_variable\nThis is a bit stupid, because you assign a variable, then return it. It would be quicker to just return 3. Luckily, the compiler will say “awww, the human has set a variable equal to something then returned it on the next line. That’s so inefficient, I’ll just ignore that”. This happens all the time. Focus your efforts on readability and learning numba. ignore little smart things: the compiler will deal with these."
  },
  {
    "objectID": "index.html#refactoring",
    "href": "index.html#refactoring",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "11.2 Refactoring",
    "text": "11.2 Refactoring\nRefactoring is the practice of taking your already-written code and making it “better”. Better is hard to define: usually you want to organise it into a more logical structure, or reduce code-duplication as much as possible. I’m getting overwhelmed by the soliton.py file so I’m going to refactor so that the Grid and Lagrangian objects get their own files. Basically, we just move the Grid class and the load_grid function into a new file called grid.py and similar for the Lagrangian.\n..\n..\n..\nOk, I did that.\nIf you run some code - it’ll break! This is because your imports currently assume that all your functions and classes are in solitons.py. And e.g. the Grid class relies on numpy which hasn’t been imported in that function.\nThe top’s of each file need updating. For grid.py, we should have\nimport json\nfrom pathlib import Path\nimport numpy as np\nfor lagrangian.py we have:\nimport pickle as pkl\nfrom pathlib import Path\nfrom typing import Callable\nimport numpy as np\nand soliton.py should contain:\nimport json\nfrom typing import Callable\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# this means, from the grid file, import Grid\nfrom .grid import Grid\nfrom .lagrangian import Lagrangian"
  },
  {
    "objectID": "index.html#init__",
    "href": "index.html#init__",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "11.3 __init__",
    "text": "11.3 __init__\nWhen we use other packages we do stuff like:\nimport numpy as np\nnp.tanh\nBut currently this syntax doesn’t work for our library. To make this work we need to expose our functions in the package initialisation script __init__.py. You do this by importing the functions and classes you’d like the user to be able to use in the file. We want the users to be able to make our three classes, and to load any of them, so we’ll expose these by modifying __init__.py as follows:\nfrom .grid import Grid, load_grid\nfrom .lagrangian import Lagrangian, load_lagrangian\nfrom .soliton import Soliton, load_soliton\nNow a user can do something like\nimport solitons1d as sol\nmy_grid = sol.Grid(100, 0.1)"
  },
  {
    "objectID": "index.html#make-a-library-of-lagrangians",
    "href": "index.html#make-a-library-of-lagrangians",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "11.4 Make a library of Lagrangians",
    "text": "11.4 Make a library of Lagrangians"
  },
  {
    "objectID": "index.html#ideas-to-build-on-the-codebase",
    "href": "index.html#ideas-to-build-on-the-codebase",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "11.5 Ideas to build on the codebase",
    "text": "11.5 Ideas to build on the codebase\nThese are all exercises:\n\nAdd time evolution. This will look a lot like gradient flow, but a bit harder.\nAllow for any boundary conditions.\nAllow for various orders of derivative."
  },
  {
    "objectID": "index.html#advice-on-making-code-and-figures-for-papers",
    "href": "index.html#advice-on-making-code-and-figures-for-papers",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "11.6 Advice on making code and figures for papers",
    "text": "11.6 Advice on making code and figures for papers\nIn this course, we’ve made a package to flow 1D solitons. And you might think that you’d only make a package for this kind of thing: something you do over and over again and that anyone can benefit from. I now believe the opposite: I make a package for every project I do. Each paper has at least one package. If the paper has distinct sections, I make a package for each. I use packages from an older paper in my newer paper packages. Packages packages packages.\nThis approach comes in especially handy when you’re making presentations, or figures. When I now make a plot, I first write a script (either a Jupyter notebook or a .py Python script) to generate the data. Then I save the data locally. When writing the script, if I write any code that seems like it would be helpful in the future, I put this into a package.\nOnce I have the data I make a different script to make the Figure. I find this separation between data generation and Figure making extremely helpful."
  },
  {
    "objectID": "index.html#tests",
    "href": "index.html#tests",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "12.1 Tests",
    "text": "12.1 Tests"
  },
  {
    "objectID": "index.html#documentation",
    "href": "index.html#documentation",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "12.2 Documentation",
    "text": "12.2 Documentation"
  },
  {
    "objectID": "index.html#linters-and-formatters",
    "href": "index.html#linters-and-formatters",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "12.3 Linters and formatters",
    "text": "12.3 Linters and formatters"
  },
  {
    "objectID": "index.html#continuous-integration",
    "href": "index.html#continuous-integration",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "12.4 Continuous Integration",
    "text": "12.4 Continuous Integration"
  },
  {
    "objectID": "index.html#recommended-reading",
    "href": "index.html#recommended-reading",
    "title": "Good Scientific Software Practices, through Solitons",
    "section": "12.5 Recommended Reading",
    "text": "12.5 Recommended Reading"
  }
]